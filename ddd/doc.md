### DDD (Domain-Driven Design)
Це підхід в розробці ПЗ, який зосереджується на глибокому розумінні предметної області із якою працює система.

Основна ідея полягає в тому, щоб вести розробку відштовхуючись від реальних бізнес процесів та вимог бізнесу, а не від технічних деталей.

Підхід розробки DDD це не тільки про розробників, в цьому підході повинна бути залучена ціла команда, які відповідає за певний домен, наприклад:
- domain expert - люди, які найкраще розуміють домен (як працює бізнес)
- product owner / product manager / analytics - люди, які забезпечують зв’язок між бізнесом та командою
- developers - люди, які реалізують логіку у вигляді коду
- tech lead / architect - людина яка відповідальна за структуру системи
- інші, хто залучений в домен 

В результаті, ми отримуємо команду яка складається із технічних та не технічних людей, які разом працюють над створенням моделі, що точно відображає бізнес-реальність, є зрозумілою для всіх учасників і може розвиватися при масштабуванні. Таким чином, DDD - це не тільки про структуру коду, а про організацію спільної роботи над складними бізнес-системами, де кожен учасник команди розуміє свій вклад у загальну модель.

Важливо розуміти, що впровадженя підходу DDD вимагає значних людських, фінансових, часових ресурсів. Не завжди впровадження DDD є виправданим, особливо якщо розробляється невеликий проект. Тому важливо розуміти чи дійсно це потрібно впроваджувати.

---

### Основні принципи стратегічного планування DDD
Організація та структура великої системи, взаємодія команд, обмеження та співпраця між контекстами. Стратегічне планування складається із: `domain`, `core domain`, `subdomain`, `supporting subdomain`, `generic subdomain`, `model`, `ubiquitous language`, `bounded context`, `context map`

`Domain`: це сфера бізнесу в якій працює ПЗ. Слід розуміти, що з розробці моделі предметної області необхідно зосередитися на певному під-домені, оскільки неможливо створити єдину модель бізнесу для всієї організації. Дуже важливо розділяти моделі на логічні розділені предметні підобласті (Subdomain) усієї предметної області, відповідно до їх фактичної функціональності. Subdomain дозволяють швидше визначити різні частини предметної області, необхідних вирішення конкретної завдання.

`Core domain`: найважливіша частина предметної області, те що дає перевагу бізнесу на ринку (умовно кажучи, найважливіша фіча). Це дуже важливий аспект підходу DDD. Зі стратегічної точки зору бізнес повинен виділятися своїм core domain. Більшість DDD проектів зосереджено саме на core domain. Найкращі розробники, експерти та вцілому команда мають бути задіяні саме у цій підобласті. Більшість інвестицій має бути спрямована саме сюди для досягнення переваги для бізнесу та отримання найбільшого прибутку.

`Subdomain (supporting subdomain)`: як було згадано вище, це виокремлена частина предметної області, що має свою власну функціональність

`Generic subdomain`: цей під-домен не має спеціального призначення для бізнесу, але потрібний для всього бізнесу в цілому, в такому випадку його називають Generic subdomain.
Вище перелічені види під-доменів є важливими для успіху бізнесу, але не мають першочергового значення. Найбільше значення має мати core domain, він повинен бути ідеально реалізованим, оскільки воно забезпечує перевагу для бізнесу.

`Model`: уявлення предметної області, яке точно описує правила, поведінку, обмеження та ін., як повинна працювати система

`Ubiquitous language`: це один з основних та найважливіших шаблонів DDD. В підході DDD є важливим, щоб терміни/фрази які використовують розробники та експерти домену були однаковими, саме тому єдину мову повинна розроблятись всією командою: експертами в домені, розробниками, бізнес-аналітиками, product менеджерами та всіма, хто залучений до створення системи. Роль у команді не важлива, оскільки кожен член команди використовує для опису проекту єдину мову. Процес створення єдиної мови не є формалізованим чи дуже чітким, він більш творчий, оскільки ця мова постійно розвивається, змінюється, старі терміни перестають використовуватись, а нові терміни додаються. У результаті залишаються тільки найстійкіші та перевірені елементи.
В підході DDD виділяють наступні методи для формування єдиної мови:
- створення глосарію із термінами та простим описом кожного терміну.
- створення документації замість глосарію, разом з термінами та описами, та іншою важливою інформацією
- обговорення готових термінів/фраз із іншими учасниками команди

Для розробника важливо уважно слухати експертів домену, для отримання максимальної кількості важливої інформації про предметну область. Також, експерти повинні прислуховуватись до розробників, щоб в результаті отримати команду діє згуртовано і глибоко розуміє бізнес.

`Bounded context`: чітко визначена межа, в якій певні терміни й моделі мають конкретне значення (за межами цього контексту, певні терміни можуть мати інше значення)
в кожному bounded context існує тільки одна єдина мова (Ubiquitous language)
мова є єдиною лише в рамках команди, яка працює над проектом в даному bounded context.
bounded context повинен бути відносно невеликим

`Context map`: діаграма або документація (або якесь інше відображення), яке показує, як різні bounded contexts пов’язані між собою. По суті, відображення зв’язків як різні під-домени між собою пов’язані. Ці поняття дозволяють ефективно ділити великі системи на менші частини

---

### Основні принципи тактичного планування DDD
Реалізація моделей всередині одного обмеженого контексту, тобто реалізація бізнес-логіки в коді. Тактичне планування складається із: `entity`, `value object`, `domain service`, `domain events`, `modules`, `aggregates`, `factories`, `repositories`

`Entity`: це об’єкт, який має ідентичність (ID) і може змінюватися з часом, але залишатися тією ж самою сутністю. В підході DDD немає єдиного формату для ідентичності об’єкта, можна використовувати як ідентичність на рівні БД (auto-increment index), UUID, чи інші варації генерування унікальних значень

`Value Object (DTO)`: це об’єкт, для якого не важлива індивідуальність, такий об’єкт повністю визначається своїми атрибутами (без прив’язки ідентичності). Для того щоб визначити чи підходить об’єкт під Value Object, можна пройтись по чек-листу:
- чи описує об’єкт предметної області
- він генерує в єдине ціле пов’язані атрибути
- його можна порівнювати з іншими об’єктами

приклад: об’єкт Money який має значення currency та amount
На практиці, такі об’єкти зустрічаються набагато частіше ніж entity.

`Domain service`: використовуючи єдину мову, іменники цієї мови перетворюються в об'єкти, а дієслова перетворюються в методи цих об'єктів. Дуже часто існують дієслова або якісь дії, які не можна віднести до якогось одного entity або value object, так як ці дії можуть відбуватись над декількома сутностями. Якщо існує така дія, то її оголошують як domain service.
- Операція, відноситься до концепції предметної області, яка не належить жодній з існуючих сутностей;
- Операція виконується над різноманітними об'єктами моделі предметної області;
- Операція немає стану;

Не потрібно зловживати domain service, так як це призводить до створення анемічної* моделі предметної області

`Domain events`: це певні події, які відбулись у системі. Ці події можна зберігати та передавати іншим частинам системи

`Modules`: групування пов’язаних части домену, тобто один модуль це одна частина предметної області

`Aggregates`: вважається що це найскладніший елемент тактичного планування DDD. По своїй суті, це група пов'язаних об’єктів (entity і value object), які ведуть себе як єдине ціле. Один з них — агрегатний корінь (Aggregate Root), через який відбуваються всі зміни. Всередині вони інкапсулюють бізнес-інваріанти (правила, які завжди повинні бути дійсними) Приклад:
```php
class Order {
    private array $items = [];
        
    private string $status = 'new';

    public function addItem(Product $product, int $qty): void
    {
        if ($this->status !== 'new') {
            throw new \Exception("Can't modify order after confirmation.");
        }

        $this->items[] = new OrderItem($product, $qty);
    }

    public function confirm(): void
    {
        if (count($this->items) === 0) {
            throw new \Exception("Can't confirm empty order.");
        }

        $this->status = 'confirmed';
        
        DomainEvents::dispatch(new OrderConfirmed($this));
    }
}
```
В цьому прикладі:
- `Order` - це є aggregate root
- `OrderItem` - внутрішня частина агрегата, напряму її не можемо змінювати
- методи `addItem` гарантує, що інваріант (правило) завжди буде виконуватись (тобто, буде виконуватись перевірка на `$this->status === 'new`), так само і в методі `confirm`

`Factories`: об’єкти які створюють складні сутності або агрегати, приховуючи деталі створення.

`Repositories`: інтерфейси для збереження та отримання даних із сховища.

---

### Приклад структурування проекту в рамках DDD

Не існує єдиного уніфікованого підходу до структурування проекту в рамках DDD, але часто можна зустріти схожу структуру яка продемонстрована нижче. На прикладі нижче, показана структура для домену `Order`. Вона складається із:
- `Domain/` - предметна область. Ядро системи, де описується модель реального світу та вся бізнес логіка. Вона може містити: `Entity`, `Value Object`, `Aggregates`, `Factories`, `Domain Service`, `Domain Events`. Цей шар в ідеалі не повинен містити залежностей від Laravel (чи будь якого іншого фреймворку), від бази даних і тд., тобто, він повинен бути максимально незалежним.
- `Application/` - сценарії використання (use cases). Тут описуються сценарії запитів від користувачів, наприклад: `confirmOrder`, `calculateDiscount`, `signUpUser`. Цей шар може містити: `application services` (сервіси, які викликають агрегати та репозиторії), `DTO`, `інтферфейси для репозиторіїв`. По-суті, цей шар координує роботу `Domain/`, але сам не містить логіки домену.
- `Infrastructure/` - цей шар реалізує доступ до зовнішніх ресурсів: репозиторії баз даних, сховища файлів, email/sms відправки, API-інтеграції
- `Interface/ or UI/` - шар, який працює із зовнішнім світом. Тут можуть бути: контроллери, cli-команди, трансформери, якісь фронт-енд компоненти, і тд.

```
app/
├── Domain/
│   └── Order/
│       ├── Entities/
│       │   └── Order.php
│       ├── ValueObjects/
│       │   └── OrderStatus.php
│       ├── Events/
│       │   └── OrderCreated.php
│       ├── Exceptions/
│       │   └── InvalidOrderStatus.php
│       └── Repositories/
│           └── OrderRepositoryInterface.php

├── Application/
│   └── Order/
│       ├── DTO/
│       │   └── CreateOrderDTO.php
│       ├── Services/
│       │   └── CreateOrderService.php
│       └── UseCases/
│           └── CreateOrderUseCase.php

├── Infrastructure/
│   └── Persistence/
│       └── Eloquent/
│           ├── Models/
│           │   └── OrderModel.php
│           └── Repositories/
│               └── EloquentOrderRepository.php

├── Interface/
│   └── Http/
│       ├── Controllers/
│       │   └── OrderController.php
│       └── Requests/
│           └── CreateOrderRequest.php
```

---

***анемічна модель** - це антипатерн у проєктуванні об’єктів у DDD (і взагалі в об’єктно-орієнтованому програмуванні), коли:
- об’єкти містять лише дані (геттери/сеттери)
- вся логіка винесена назовні (в окремі сервіси)

Тобто це моделі, які виглядають як DTO (data transfer objects), але прикидаються сутностями.