Чистий код:

Перемінні:

Функції:
- повинні бути компактними, до 20 рядків коду (порада автора)
- функція повинна виконувати тільки 1 операцію
- краще не використовувати функції із великою кількістю аргументів. Ідеальна функція, це та функція яка немає аргументів. Функції в яких більше 3-ьох аргументів, потрібно старатись не створювати.
- старатись не використовувати аргументи-прапори (вони означають що будуть 2 сценарії в функції, що в свою чергу ускланює читання, тестування функції, збільшує ймовірність помилки)
- якщо є функція із більше ніж 2-3 аргументами, можна розглянути можливість щоб об'єднати декілька аргументів в інший клас, якщо він логічно пов'язаний. Наприклад якщо функція очікує аргументи `street_address`, `zip`, `city` і тд., то можна створити об'єкт `Address`, в якому буде зберігатись ця інформація і далі цей об'єкт передавати в функцію.
- функція повинно або змінювати стан об'єкта, або повертати інформацію про цей об'єкт. Змішування цих двух операцій створює плутанину

Коментарі:
- по-хорошому, коментарі не повинні існувати в коді, якщо вони є, цe означає що код не достатньо добре написаний щоб в ньому розібратись без коментарів. Та все ж, в реальному світі без коментарів часто не можливо обійтись.
- перед тим як написати коментар, задайте собі питання "чи можу переписати код щоб він став зрозумілішим і не прийшлось писати коментар?"
- все ж таки, коментарі можуть існувати для пояснення певних частин коду, але перед цим потрібно переконатись що вони дійсно потрібні тут. Принцип той самий, перепитати себе чи дійсно коментар тут потрібний.

Форматування:
- якщо одна функція залежить від іншої, то тримати їх потрібно поруч один біля одної. В ідеалі, щоб основна функція була зверху і під нею функція яку викликають. Тобто, є публічний метод який викликає приватний метод, в такому випадку краще щоб спершу був публічний метод і потім приватний метод. Щоб, коли хтось буде читати цей клас, він міг його читати зверху в низ і воно було логічно розташовано. 
- логічні елементи коду можна в функції можна відділяти пустим рядком. Тобто, якщо в функції виконуються декілька рядків коду які є логічними (пов'язаними) між собою, то вони можуть бути розташовані один за одним, а наступна логічна частина, може бути розділена пустим рядком.
- не потрібно робити рядки занадто довгими, автор рекомендує до 100-120 символів. 
- потрібно зробити один формат написання коду для всієї команди, та задокоментувати це на рівні IDE, щоб всі дотримувались

Обʼєкти та структури даних:
- чим об'єкти відрізняються від структур даних. Об'єкти приховують свої дані за абстракціями і надають функції які працюють із цими даними. Структура даних відкриває свої дані і не має змістовних функцій
- добре відоме правило яке зветься законом Деметрі, каже що модуль не повинен знати внутрішнє влаштування тих об'єктів, із якими він працює. Об'єкти повинні приховувати свої дані, та надавати операції для роботи із ними.
- DTO - структури даних, які використовуємо як прослойка для передачі даних між рівнями програми. DTO - містять публічні перемінні.
- Bean-компоненти - різновид DTO, де ми робимо перемінні об'єкта приватними, і для них робимо сетери та гетери (автор не рекомендує цього).
- також є різновид який називається Active record, це означає що він може мати методи save, find. Active record - частіше всього являється відображенням даних із таблиць БД або інших джерел даних. Часто в Active record - включать бізнес-логіку, але це не потрібно, тому що створює плутанину із структури даних та об'єктом. Active records - повинен розглядатись як структура даних, і в програмі створюються окремі об'єкти для обробки бізнес-логіки

Виключення (Exceptions):
- кожний exception яке ініціюється в програмі, повинно містити достатньо контекстної інформації для визначення джерела та місцезнаходження помилки.
- не повертати null із функції. Якщо ви повертаєте null із функції, то той хто викликає цю функцію повинен перевірити чи значення не рівне null. Це викликає зайву роботу і покладає відповідальність на того хто викликає цей метод. Також, може виникнути ситуація коли таких перевірок декілька, що в свою чергу збільшує складність коду та призводить до можливої помилки. Потрібно завжди розглядати можливість, чи можемо замість null викинути exception, зробити null-об'єкти чи можливо можемо повернути значення за замовчуванням чи наприклад пусте значення (якщо масив - то значить пустий масив). Інколи сторонні API-бібліотеки можуть повертати null, в цьому  випадку краще зробити функцію обгортку для таких ситуацій

Границі:
- коли ми використовуємо сторонню бібліотеку, нам потрібно читати документацію, пробувати написати код для перевірки роботи пакета, дебагом помилок які з'являються і тд. Автор рекомендує використовувати методологію 'навчальні тести', вони означають що ми пишемо тести для API методів із бібліотеки які нам потрібно використовувати, і таким чином можемо краще зрозуміти функціонал пакету, чи робить він те, що нам потрібно.

Класи:
- чому потрібно дотримуватись принципів єдиної відповідальності та відкритості/закритості? Тому що, якщо ми порушуємо цей принцип, і хочемо додати новий функціонал в існюучий клас (новий метод чи методи), ми потенційно можемо принести помилки в існуючий функціонал. Приклад, є клас `Sql` і в ньому всі метод пов'язані із `CRUD операціями`, якщо нам треба додати новий функціонал, це потенційно може принести помилки в існуючий функціонал. В цьому випадку краще зробити клас `Sql`, та класи `InsertSql`, `CreateSql` і тд. І якщо нам наприклад треба створити новий функціонал `update`, ми робимо клас `UpdateSql`. І таким чином ми не вносимо зміни в основний код, а розширюємо функціонал за рахунок нового класу

Запахи кода
- прапори в аргументах функції. Логічно явно вказують на те, що функція виконує більше ніж одну операцію. Вони сильно заплутують код
- не зловживати статичними методами. Статичні методи можна робити якщо потенційно цей метод не потрібно буде робити поліморфним, а він залишиться із поточною реалізацією
- використовувати пояснюючі перемінні. Приклад
```
  if(match.find())
  {
    String key = match.group(1);
    String value = match.group(2);
    headers.put(key.toLowerCase(), value);
  }
  
  Створивши перемінні key, value - ми точно знаємо що там знаходиться ключ та значення. Це зрозуміліше ніж ось такий приклад
  if(match.find())
  {
    headers.put(match.group(1).toLowerCase(), match.group(2));
  }
```
- імена функцій повинні описувати операцію яку будуть виконувати (бути дієсловами)
- уникайте негативних умов
```
  Негативні умови трохи складніші для розуміння, ніж позитивні. Таким чином, по можливості старайтесь формулювати позитивні умови. Наприклад, запис
  if (buffer.shouldCompact())
  кращий для запису ніж
  if (!buffer.shouldNotCompact())
```