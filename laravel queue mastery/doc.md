Основна ідея:
- `JOB` - клас який буде відправляти в чергу. Приклад в нас є клас `SendEmailJob`, і в цьому класі в методі `handler` виконується відправлення емейлу. Ми поміщаємо цю джобу в чергу, це можна зробити через глобальний хелпер `dispatch(SendEmailJob::class)`, або `SendEmailJob::dispatch()`. В залежності від наших налашнтувань, ми можемо мати чергу в `database`, `redis`, `sqs`, etc. Поклавши цю джобу в чергу, далі нам потрібно її дістати із черги та виконати. Для цього потрібно використати `php artisan queue:work`, ця команда дістає та виконує джобу. Все, наша джоба виконалась і черга буде пуста.
- `JOB` - клас який містить логіку яку потрібно обробити
- `dispatch()` - метод який відправляє джобу в чергу
- `php artisan queue:work` - команда яка запускає воркер, який отримує джоби із черги та виконує їх 

---

Конфігурування:
- `delay()` - метод який використовується для затримки виконання джоби. Тобто, вона потрапить в чергу, але виконуватись одразу не буде. Приклад, `SendEmailJob::dispatch()->delay(5)` - означає що джоба виконається через 5 сек після потрапляння в чергу
- `public $timeout` - в джобі ми можемо створити публічну проперті `public $timeout = 1`, що означає що якщо джоба не встигне виконатись за 1сек, то воркер зробить terminate цій джобі
- `public $tries` - також в джобі ми можемо створити публічну проперті `public $tries = 3`, що означає що якщо джоба була зафейлина 3 рази, то тільки після цього вона буде помічена як `failed`. Відповідно, якщо джоба була зафейлина 1 раз, то воркер спробує 2-ий раз виконати цю джобу, якщо знову фейл, то воркер спробує викнати 3-ій раз цю джобу. Якщо на 3-ій раз зафейлилась, то вона буде помічена як failed.
- `public function retryUntil()` - метод, який ми можемо реалізувати в класі `SendEmailJob`, цей метод повинен повертати об'єкт `DateTime`, ми можемо вказати наступне `return now()->addMinutes(10);`. Це означає що, якщо джоба зафейлилась, то вона буде пробуватись виконатись іще, до поки не пройде 10хв (поки не стане expired). Тобто, за цей час джоба якщо зафейлилась, то вона може пробувати виконатись іще дуже велику кількість разів. Також, треба вказати `public $tries = -1;`, щоб кількість спроб була безлімітна, до поки не пройде 10 хв
- `public $backoff = 1` - це проперті означає, що якщо джоба зафейлилась, то вона спробує виконатись через 1сек. Тобто, якщо раніше джоба фейлилась, то вона одразу пробувала виконатись, без затримки в часі. А це налаштування означає, що джоба почекає 1 сек між фейлами
- `public $backoff = [1, 5, 10]` - також, можемо передати масивом, що означає затримка буде 1сек після 1-го фейлу, далі затримка буде 5сек після 2-го фейлу, і після 3-ього фейлу затримка буде 10сек 
- `->onQueue('queue_name')` - ми можемо створити чергу із окремим іменем. За замовчуванням всі джоби потрапляють в чергу `default`, в нас може виникнути ситуація коли ми наприклад маємо джобу `ProcessPaymentJob`, яка є більш приоритетною ніж `SendEmailJob`, але в нас вже черга заповнена джобами по відправці емейлу. В цьому випадку ми хочемо надати більший приоритет для джоб `ProcessPaymentJob`. Ми можем зробити наступне - `ProcessPaymentJob::dispatch()->onQueue('payments')` - тобто, в методі `onQueue('payments')` вказуємо чергу `payments`, розділяємо черги `payments` та `default`. Далі, ми можемо запустити іще один воркер `php artisan queue:work --queue=payments,default` - що означає, що спочатку опрацьовує джоби із чергу `payments`, і тільки потім джоби із черги `default`.
- `ShouldBeUnique` - це інтерфейс, який ми можемо реалізовувати в нашій джобі. Цей інтерфейс означає що, дана джоба може бути тільки одна в черзі, якщо спробувати додати декілька джоб в чергу - не получиться
- `uniqueId()` - метод (або проперті) який можемо реалізувати в джобі. По замовчуванні, назва класу це і є id джоби, якщо треба змінити id джоби, можемо використати цей метод. Це може бути корисним в комбінації із пунктом вище (про `ShouldBeUnique`). Тобто, ми маємо джоби `Run2E2Tests`, `RunIntegrationTests`, але хочемо щоб тільки одна із цих джоб була в черзі в момент часу (ці 2 джоби не повинні бути в черзі в один і той самий момент). В цьому випадку ми можемо реалізувати метод `uniqueId('tests')` для обох джоб і щоб обидві джоби реалізовували інтерфейс `ShouldBeUnique`.
- `uniqueFor()` - метод (або проперті) який ми можемо реалізувати в джобі. Воно означає скільки секунд джоба може бути унікальною в черзі. Якщо встановимо 60сек, то через 60сек <span style="color:red">існуюча джоба зафейлиться чи видалиться і додасться нова джоба? чи просто додасться нова джоба до цієї що вже існує в черзі? (походу 2-ий варіант, просто додасться нова джоба до вже існуючої)</span>
- `ShouldBeUniqueUntilProcessing` - це інтерфейс який означає наступне. Коли в нас є інтерфейс `ShouldBeUnique` - то це означає що джоба в черзі повинна бути унікальною до поки вона не опрацюється успішно або поки не зафейлиться. Якщо ми хочемо щоб наступна джоба додалась в чергу ДО моменту поки джоба із черги опрацюється або зафейлиться, тобто, як тільки джоба береться в роботу і ми хочемо закинути одразу наступну джобу в чергу, то ми повинні використовувати цей інтерфейс `ShouldBeUniqueUntilProcessing`

---

Handling attempts & Failures
- якщо джоба була зафейлина, вона потрапляє в таблицю `failed_jobs` (автор показує приклад із драйвером `database`, цікаво чи фейлині джоби потрапляють в `database`, якщо наприклад драйвер буде `redis`?)
- ми можемо взяти із таблиці uuid зафейлиної джоби і спробувати запустити її іще раз використовуючи команду `php artisan queue:retry uuid`. Таким чином, ми відправляємо цю зафейлину джобу назад в чергу  
- `relase()` - ???
- `public $maxEceptions = 2` - також, можемо конфігурувати яка кількість максимальних exceptions може виникнути перед тим як помітити джобу failed. Наприклад в нас вказано `public $tries = 10; public $maxExceptions = 2`, то в цьому випадку якщо відбудеться 2 фейли через exception, джоба буде помічена як failed.
- `public function failed($e)` - в джобі ми можемо реалізувати метод `failed($e)`, який очікує exception який був викинутий. Ми можемо в цьому методі реалізувати якусь нам потрібну логіку (наприклад щось залогувати)

---

Workflows, Chain, Batches
- інколи нам потрібно виконати декілька джоб один за одним які між собою логічно пов'язані, в Ларавел існує 2 види для цього що звуться `chain`, `batches`
- `chain` - приклад, ми маємо 3 джоби які логічно пов'язані між собою і повинні виконуватись одна за одною. `Chain` означає що ці джоби будуть виконуватись одна за одною, і якщо одна джоба буде зафейлина, то буде зафейлений весь `chain` цих джоб
```
    $chain = [
        new PullRepoJob(),
        new RunTestsJob(),
        new DeployJob(),
    ];
    
    \Illuminate\Support\Facades\Bus::chain($chain)->dispatch();
```
- `batch` - метод схожий до `chain`, але в ньому відмінність, що якщо джоба буде зафейлина в `batch`, то наступні джоби будуть відпрацьовуватись. Також, потрібно додати трейт `Batchable` в джоби і запустити команду `php artisan queue:batches-table`, це створить міграцію і далі нам потрібно запустити цю міграцію. 
```
    $batch = [
        new PullRepoJob('project1'),
        new PullRepoJob('project2'),
        new PullRepoJob('project3'),
    ];
    
    \Illuminate\Support\Facades\Bus::batch($batch)->dispatch();
```
- <span style="color:red">`batch` - не зрозуміло наступне 'The batch method is used to group multiple jobs into a batch, and these jobs can be executed concurrently or sequentially'</span>
- <span style="color:red">`batch` - не зрозумілий приклад коли `$this->batch()->cancelled()`, і іще щось якщо якась джоба зафейлилась то весь batch помічений як cancelled. Цікаво, на що впливає цей cancelled статус? бо наступні джоби ж повинні виконуватись не дивлячись на те що якась джоба в batch була зафейлина</span>
- `catch` - в ланцюгу об'єкта `Bus` є також метод `catch`. Цей метод буде викликаний якщо відбудеться фейл якоїсь джоби в `chain` або `batch` методах
```
    $chain = [
        new PullRepoJob(),
        new RunTestsJob(),
        new DeployJob(),
    ];

    Bus::chain($chain)
        ->catch(function ($chain, $exception) {
            // write some logic
        })
        ->dispatch();
        
    $batch = [
        new PullRepoJob('project1'),
        new PullRepoJob('project2'),
        new PullRepoJob('project3'),
    ];
        
    Bus::batch($batch)
        ->catch(function ($batch, $exception) {
            // write some logic
        })
        ->dispatch();    
```
- `onQueue`, `onConnections` - також, ми можемо вказати що хочемо відправити `chain` або `batch` в якусь конкретну чергу і також можемо вказати що хочемо відправити їх в якийсь конкретний драйвер
```
    $chain = [
        new PullRepoJob(),
        new RunTestsJob(),
        new DeployJob(),
    ];

    Bus::chain($chain)
        ->catch(function ($chain, $exception) {
            // write some logic
        })
        ->onQueue('deployments')
        ->onConnection('database')
        ->dispatch();
```
- `then`, `finnaly`, `progress`, `catch` - існують методи які можуть виконуватись на різних етапах роботи джоб із `batch`
```
    $batch = Bus::batch([
        new ImportCsv(1, 100),
        new ImportCsv(101, 200),
        new ImportCsv(201, 300),
        new ImportCsv(301, 400),
        new ImportCsv(401, 500),
    ])->progress(function (Batch $batch) {
        // A single job has completed successfully...
    })->then(function (Batch $batch) {
        // All jobs completed successfully...
    })->catch(function (Batch $batch, Throwable $e) {
        // First batch job failure detected...
    })->finally(function (Batch $batch) {
        // The batch has finished executing...
    })->dispatch();
```
- `chained batches` - якщо дивитись приклад нижче, то бачимо що в методі `batch` передається багатомірний масив. В першому масиві передаються 2 джоби які відпрацюють як `chain` і в другомі масиві так само передаються 2 джоби які так само відпрацюють як `chain` - тобто, одна за одною. Метод `then` спрацює джоби в цих двух масивах відпрацюють. 
```
    Bus::batch([
        [
            new ReleasePodcast(1),
            new SendPodcastReleaseNotification(1),
        ],
        [
            new ReleasePodcast(2),
            new SendPodcastReleaseNotification(2),
        ],
    ])->then(function (Batch $batch) {
        // ...
    })->dispatch();
```

---

Controlling and Limiting Jobs

- <span style="color:red">`Cache::lock('deployments')->block(10, function () {})` - розібратись</span>
- <span style="color:red">`Redis::funnel()` - розібратись</span>
- <span style="color:red">`Redis::throttle()` - розібратись</span>
- <span style="color:red"> - розібратись </span>
```
    public function middleware() {
        return [
            new WithoutOverlapping('deployments', 10);
        ];
    }
```

---

Міддлвар

- `ThrottlesExceptions` - це мідлвар який означає наступне. Наприклад в нас є АПІ яке не є стабільним, і воно починає повертати помилку. І в нас є джоба в черзі яка робить API реквест до цього ресурса. То ми можемо вказати, якщо ми отримуємо 10 exception на протязі 5хв в цій джобі, то ми зупиняємось на 5хв і потім ця джоба знову буде пробувати виконатись 
```
    public function middleware(): array
    {
        return [new ThrottlesExceptions(10, 5)];
    }
```

---

Інше

- може бути ситуація коли в нас виконується джоба в транзакції. На прикладі нижче в транзакції ми створює юзера і відправляємо йому welcome емейл, може трапитись ситуація що: ми створили юзера, відправили джобу в чергу, воркер бере із черги цю джобу і пробує її виконати, але транзакція іще не закінчилась і в нас немає цього юзера в БД, в цьому випадку отримаємо помилку. Щоб цього уникнути ми можемо використати метод `afterCommit()`, цей метод означає що джоба буде відправлена в чергу після коміту транзакції
```
    // може не працювати
    DB::transaction(function () {
        $user = User::create();
        SendWelcomeEmail::dispatch($user);
    });
    
    // джоба додасться в чергу після коміту транзакції
    DB::transaction(function () {
        $user = User::create();
        SendWelcomeEmail::dispatch($user)->afterCommit();
    });
```
- ми також можемо конфігурувати це глобально. В файлі `queue.php` в потрібно драйвері вказуємо `after_commit => true`
- в нашій джобі ми повинні звести до мінімума залежності. Так як, джоба перед відправленням в чергу повинна бути сериалізована і потім коли із черги ми дістаємо цю джобу її треба десереалізувати, то ми затрачаємо досить багато ресурсів на це.
- не потрібно передавати в нашу джобу якусь сенсетів інформацію чи креденшели, тому що коли джоба сериалізується, і зберігається в черзі, то значення цих секретних даних буде видно. Щоб зашифрувати пейлоад джоби, можемо використати інтерфейс `ShouldBeEncrypted` інтерфейс для цієї джоби

---

Supervisor

- це система управління процесами для Unix-подібних операційних систем. Він використовується для керування та контролю процесів, гарантуючи, що вони продовжують працювати та можуть бути налаштовані на автоматичний перезапуск у разі збою. Supervisor часто використовується для керування довготривалими процесами, демонами та фоновими завданнями.
- налаштування supervisor знаходиться в `/etc/supervisor/conf.d`. В цій директорії можемо створити файли конфігурацій, наприклад `extra-workers.conf`.

Приклад файлу налаштувань
![img.png](img.png)
- `[program:extra-workers]` - ім'я нашої програми. Ми його використовуємо коли потрібно запустити, зупинити воркер
- `command=php /home/forge/laracasts.demo/artisan queue:work` - назва команди яка запускається при запуску цього воркера (цього файлу конфігурацій)
- `autostart=false` - супервайзер не запускає автоматично програму коли робимо рестарт сервера
- `numprocs=3` - 3 процеса які запускають цю команду

Команди
- `supervisorctl reread` - команда для того щоб зчитати нові конфігурації 
- `supervisorctl update` - <span style="color:red;">???</span>
- `supervisorctl start extra-workers:*` - запустити воркери
- `supervisorctl stop extra-workers:*` - зупинити воркери

Поради від автора
- щоб не запускати вручну старт і стоп команди для супервізора, можна налаштувати крон який буде запускати та зупиняти супервізор в певний період дня (за умови якщо ми знаємо що в якийсь період дня буде навантаження і нам потрібні будуть воркери)
- якщо в нас немає розпорядку для запуска воркерів, ми можемо зробити наступне. Зробити крон команду, яка буде запускатись кожні 10хв, і ця команда буде перезапускати воркери якщо є якісь черги для обробки, якщо черг немає, то воркери не запустяться. Команда `php /home/forge/laracasts.demo/artisan queue:work --stop-when-empty`

---

Horizon

Налаштування
- ![img_1.png](img_1.png)
- `queue => ['deployments', 'notifications']` - які черги будуть оброблятись
- `minProcesses => 1` - мін кількість воркерів
- `maxProcesses => 10` - макс кількість воркерів
- <span style="color:red;">horizon за замовчуванням додає або видаляє воркер кожні 10сек. Для того щоб змінити цю поведінку можемо використати налаштування нижче. Але цю інформацію треба перевірити</span>
- `balanceMaxShift => 3`, `balanceCooldown => 1` - означає що кожну секунду будуть додаватись або видалятись 3 воркери