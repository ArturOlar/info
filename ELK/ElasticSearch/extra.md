### Реіндексація документів

Реіндексація документів - це наповнення документів із одного індекса в інший індекс.

- приклад 1: в нас є індекс `products` в якому є поле `product_id` із типом `integer`, нам потрібно змінити цей тип на `keyword`. Для цього створюємо новий індекс `products_new` в якому вказуємо `product_id` із типом `keyword`. Далі, використовуємо API для реіндексації документів, тобто, копіюємо всі документи із таблиці `products` в таблицю `products_new`. Після цього, видаляємо таблицю `products`.
- приклад 2: в нас є індекс `products` в якому є поле `product_id` яке ми хочемо видалити. Для цього використовуємо API для реіндексу, де вказуємо які поля хочемо реіндексувати (очевидно що поле `product_id` не потрібно вказувати).
```
POST /_reindex
{
  "source": {
    "index": "products",
    "_source": ["title", "description", "price"]
  },
  "dest": {
    "index": "products_new"
  }
}
```
- приклад 3: в нас є індекс `products` в якому є поле `rating`, нам потрібно створити новий індекс із продуктами в яких рейтинг більше 3. Для цього використовуємо API для реіндексації документів, тобто, копіюємо всі документи із індекса `products` в яких `rating` більше ніж 3, в індекс `products_new`. Приклад нижче
```
POST /_reindex
{
  "source": {
    "index": "products",
    "query": {
      "range": {
        "rating": {
          "gte": 3.0
        }
      }
    }
  },
  "dest": {
    "index": "products_new"
  }
}
```

---

### Трохи інфи про механізим

`Routing` - це механізм, який використовується в Elastic для керування роутингу `documents` у `shards` на основі роутинга. В Elastic роутинг працює за замовчуванням і також можна створювати кастомний (якщо це потрібно, тому що в 99% підходить дефолтний роутинг). Роутинг відповідає за те, а якому шарді буде збережений документ, і відповідно щоб потім із цього шарда дістати цей індекс при пошуку. Elastic, визначає потрібний шард на основі: мета-поля `_id` в документі, кількість шардів в індексі (саме тому кількість шардів можна вказати тільки при створенні індекса, і не можна оновити)

`Як Elastic виконує write операції` - спочатку реквест потрапляє в `routing` про який було описано вище, щоб зрозуміти в який шард потрібно записати документ. Маючи конкретний шард, Elastic записує дані в `primary shard`, валідує дані, паралельно розприділяє документ в `replica shard` якщо такі є.

`Versioning` - Elastic версіонує документи. В документі в мета-даних є атрибут `_version`. Цей атрибут збільшується коли ми оновлюємо документ. Коли видаляємо документ, то цей документ буде збережений іще 60 сек, і якщо на протязі цих 60 сек створити документ із такими самим `_id`, то версія документа збільшиться на 1. Якщо створити документ із таким самим `_id` після 60 сек, то версія документа буде 1. Також, попереді версії документів не можна переглядати, тобто якщо є документ із версією 3, то подивитись версії 1 та 2 - ми не можемо.

`Optimistic councurrency control` - механізм який дозволяє опрацьовувавти ситуації коли в один і той самий момент пробуємо оновити один і той самий ресурс. Наприклад: в нас є індекс 'products' і в кожного документа є 'in_stock', де вказуємо кількість доступних товарів. Якщо два запити одночасно будуть оновлювати значення 'in_stock', то може виникнути ситуація коли перший запит оновить значення із 5 на 4, і другий запит оновить значення теж із 5 на 4, але в реальності мало б бути оновлено із 4 на 3. За замовчуванням це так і буде працювати. Та ми можемо використати наступний механізм. В мета-даних документа є атрибути `_seq_no`, `_primary_term`, коли відправляємо запит на оновлення документа, то в запиті потрібно вказати ці атрибути, таким чином Elastic оновить значення 'in_stock' і значення цих атрибуті. Таким чином наступний запит буде використати старі значення `_seq_no` та `_primary_term`, і Elastic не дозволить оновити документ, буде помилка від Elastic. Note: нам потрібно в нашому апілкейшині написати код для обробки цих помилок, Elastic самостійно це не обробляє