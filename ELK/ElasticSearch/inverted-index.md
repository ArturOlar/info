### Inverted Index

`inverted index` - це спеціальна структура даних, в якій дані розміщенні таким чином, щоб можна було виконувати ефективно full-text пошук. Дані в цьому індексі груповані по tokens/terms (по словах) і містять посилання на документ (вказано в яких документах ці слова зустрічаються). Це в свою чергу, дає змогу швидко виконувати full-text пошук, знаходити в яких документах зустрічається слово яке нам потрібно знайти. <br>
`token(s)/term(s)` - це термін який означає одне й те саме, а саме це одиниця даних в `inverted index`. <br>
Структура даних `inverted index` працює тільки із полями в яких тип даних `text` в індексі. Тому що ця структура ефективно працює тільки для текстових даних по яких потрібно проводити пошук. Для полів із іншими типами даних (наприклад: `integer`, `keyword`, `date`, і тд), ця структура не є найбільш ефективною, тому там використовуються інші структури даних для ефективного пошуку даних.

---

Флоу як працює `inverted index`:
- Після того, як дані було токенізовано, створюється `inverted index`, щоб зробити мапінг кожного токена з документами де цей токен зустрічається.
- Для кожного токена `inverted index` зберігає список ідентифікаторів документів (або `pointers` їх називають), де зустрічається цей токен. Цей список називається `posting list`.
- Крім того, `inverted index` зберігає додаткову інформацію про кожен токен, наприклад `frequency` (як часто токен з’являється в документі), `position information` (розташування токена в документі).
- `inverted index` створюється для кожного текстового поля в документі. Якщо в нас є індекс `products`, із 2-ма текстовими полями: `name` та `description`. Це означає що elastic створить 2 індекса: `inverted index for field name` та `inverted index for field description`.
- `inverted index` зберігає токени в відсортованому вигляді, для ефективнішого пошуку в подальшому.
- Кожна структура `inverted index` займає пам'ять, тому важливо створювати `inverted index` тільки для тих полів, по яких планується проводити full-text пошук. 

---

Приклад:
- Уявимо що ми маємо просту колекцію із документів які містять наступний текст:
  - document 1: "Elasticsearch is fast."
  - document 2: "I want to learn Elasticsearch!"
- Після токенізації, токени будуть розділені ось так:
  - document 2: ["elasticsearch", "is", "fast" "i", "want", "to", "learn"]
- `inverted index` буде виглядати приблизно як нижче. Тобто, будується таблиця яка містить `tokens`, `count` - скільки разів зустрічається цей токен, `document : position` - id документів та позиція де зустрічається цей токен
- Варто звернути увагу що символи `.`, `!` відсутні в `inverted index`, це тому що ми не хочемо такі дані зберігати в індексі. Ці символи видаляються на моменті токенізації (`Tokenizer`) під-час аналізу даних
```
Tokens         | Count    | Document : Position
----------------------------------------
elasticsearch  | 2        | 1:1, 2:5
is             | 1        | 1:2
fast           | 1        | 1:3
i              | 1        | 2:1
want           | 1        | 2:2
to             | 1        | 2:3
learn          | 2        | 2:4
```
- Далі, під час виконання пошукового запиту `inverted index` дозволяє ефективно шукати конкретні документи, які містять певні токени які потрібно знайти.
- Для прикладу: якщо юзер буде шукати слово 'fox', пошукова система шукає в `inverted index` слово 'fox', знаходить його і може дістати id документів які пов'язані із цим токеном. Далі, пошукова система точно знає які саме `documents` потрібно дістати.
