### Mapping

Mapping - визначає структуру індекса (які поля в індексі повинні бути та їх типи даних). Це можна сказати аналогія `schema` в реляційних базах даних. <br>
В elastic є 2 метода для мапінгу: явний (`Explicit`) та не явний (`Dynamic`). Тобто, коли ми самостійно вказуємо мапінг і коли це робить elastic автоматично замість нас. Також, ми можемо зкомбінувати явний та не явний мапінг.

---

- Dynamic Mapping:
  - Elastic підтримує динамічний мапінг. Це означає що Elastic cамостійно визначає тип даних, задає тип даних полю. Наприклад: прийшли дані "Hello World", Elastic - в цьому випадку самостійно визначить що тип даних `text`
  - тому, якщо ми явно не вказуємо мапінг для документа, то Elastic буде робити мапінг - самостійно. Це може бути не добре, тому що ми явно не вказуємо які саме поля повинні бути в індекс.

- Explicit Mapping:
  - відповідно ми можемо явно вказувати мапінг для схеми документа при створенні індекса. Явний мапінг дозволяє контролювати як `fields` інексуються та аналізуються
  - тобто, ми можемо явно вказувати тип даних для полів, визначити аналізатор, задати якісь налаштування для поля
  - відповідно, якщо в нас поле вказано як `int`, а ми спробуємо вставити текстові дані - то отримаємо помилку
  - навіть якщо ми явно вказуємо мапінг для індекса, це не означає що ці поля будуть required. Тобто, elastic працює таким чином, що всі поля є optional.


- Змінити data type для поля в індексі не можливо. Можна змінювати деякі параметри для поля, але data type - ні. Щоб змінити тип даних для поля, в elastic існує спеціальний reindex API (див в `extra.md` та `API/reindex.md`) для реіндексації документів.
- Видалити поле із індекса не можливо. Для цього, можна скористатись API для реіндексу
- Перейменування полів в індексі також не можливе. Для цього, можна використати API для реіндексу

---

### Explicit Mapping

Приклад явного мапінга:
```
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text"
      },
      "category": {
        "type": "keyword"
      },
      "price": {
        "type": "float"
      },
      "created_at": {
        "type": "date",
        "format": "yyyy-MM-dd HH:mm:ss"
      }
    }
  }
}
```

На прикладі вище ми вказали які поля повинні бути в індексі та який тип даних вони повинні мати. 

---

### Dynamic Mapping

#### `dynamic` опція

- ми можемо використовувати явний та не явний мапінг одночасно. На прикладі нижче, ми створили явний мапінг для поля `first_name`, та динамічний мапінг для поля `last_name`. 
```
PUT /people
{
  "mappings": {
    "properties": {
      "first_name": {
        "type": "text"
      }
    }
  }
}

POST /people/_doc
{
  "first_name": "John",
  "last_name": "Doe"
}
```
- ми можемо конфігурувати поведінку не явного мапінгу. На прикладі нижче вказана опція `"dynamic": false`, яка означає що в `inverted index` будуть потрапляти тільки ті поля, які перелічені при створенні індекса. Відповідно, на прикладі нижче поле `last_name` в `inverted_index` не потраплятиме, і в подальшому ми не зможемо проводити пошук по цьому полі. Але саме поле `last_name` буде існувати в документі, для нього просто не буде створено `inverted_index` і не можна буде провидити пошук.
```
PUT /people
{
  "mappings": {
    "dynamic": false,
    "properties": {
      "first_name": {
        "type": "text"
      }
    }
  }
}

POST /people/_doc
{
  "first_name": "John",
  "last_name": "Doe"
}
```
- ми можемо вказати `"dynamic": "strict"`, який означає що якщо ми спробуємо вставити поле, яке не було вказано в явному мапінгу, то elastic буде повертати помилку.  
```
PUT /people
{
  "mappings": {
    "dynamic": "strict",
    "properties": {
      "first_name": {
        "type": "text"
      }
    }
  }
}

// elastic returns an error
POST /people/_doc
{
  "first_name": "John",
  "last_name": "Doe"
}
```
- якщо в нас поле типу `object`, то опція `"dynamic": true/false/"strict"`, діє і для дочірніх елементів, але ми також на дочірніх елементах можемо змінити значення `"dynamic"`. На прикладі нижче, вказуємо для всіх полів об'єкта `"dynamic: strict"`, але для поля `other` та його дочірніх полів вказуємо `"dynamic: false"`.
```
PUT /computers
{
  "mappings": {
  
    // вказуємо strict мапінг для всіх полів
    "dynamic": "strict",
    "properties": {
      "name": {
        "type": "text"
      },
      "specifications": {
        "properties": {
          "cpu": {
            "properties": {
              "name": {
                "type": "text"
              }
            }
          },
          "other": {
          
            // змінюємо значення dynamic, поля можуть бути із динамічним мапінгом
            "dynamic": true,
            "properties": { ... }
          }
        }
      }
    }
  }
}
```
- для `numeric` типів даних існує опція `"numeric_detection": true/false`. При включенні цієї опції, elastic спробує конвертувати поля в тип даних `float` чи `long`. Якщо опція виключена, то значення будуть із типом `text`.
```
PUT my-index-000001
{
  "mappings": {
    "numeric_detection": true
  }
}

PUT my-index-000001/_doc/1
{
  "my_float":   "1.0", # long
  "my_integer": "1"  # float
}
```
- для `date` типів даних існує опція `"date_detection": true/false`. При включенні цієї опції, elastic спробує конвертувати поля в тип даних `date` (за замовчуванням опція включена). Якщо опція виключена, то значення буде із типом `text`.
```
PUT my-index-000001
{
  "mappings": {
    "date_detection": false
  }
}

PUT my-index-000001/_doc/1 
{
  "create_date": "2015/09/02" # text
}
```

---

### Mapping Recommendations

- використовувати явний мапінг
  - динамічний мапінг - це зручно, але ми втрачаємо певний контроль над структурою індекса
  - при використанні явного мапінгу, ми можемо зберегти пам'ять на диску, за рахунок правильного мапінгу полів. Динамічний мапінг може мапити поле як тип `text`, і це займає додаткову пам'ять в диску, але по-факту, це поле не потрібно щоб було типу `text`.
  - встановлювати `"dynamic": "strict"`, замість `"dynamic": false`.
    - дозволяє уникнути не сподіваних результатів


- мапінг для текстових полів
  - не використовуйте завжди обидва типи `text` та `keyword` для поля (окрім випадків, коли це дійсно потрібно).
    - зазвичай, тільки один із типів потрібний
    - кожний мапінг потребує пам'яті
  - чи буде використовуватись поле для full-text пошуку?
    - додати `text` мапінг
  - чи потрібно робити: агрегацію, сортування чи фільтрування по конкретному значенні (exect values)?
    - додати `keyword` мапінг


- виключити `coercion`
  - заставляє нас завжди використовувати правильні типи даних 


- використовувати відповідні numeric типи даних
  - для всіх numeric типів даних, `integer` тип даних в більшості випадків є достатнім
    - тип `long` може зберігати більші числа, але при цьому він потребує більше пам'яті
  - для чисел із плаваючою крапкою, тип даних `float` для більшості випадків має бути достатнім
    - `double` зберігає числа з вищою точністю, але використовує вдвічі більше місця на диску
    - зазвичай `float` забезпечує достатню точність


- параметри для мапінгу. 
  - `doc_values: false` якщо нам не потрібно: sorting, aggregations, чи scripting. Це дозволяє зберегти дискову пам'ять.
  - `norms: false` якщо не потрібний relevance scoring
