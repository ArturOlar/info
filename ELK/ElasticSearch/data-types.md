
### Data Types

В еластіку є досить багато типів даних, багато із яких є специфічними, наприклад тип даних `ip` для зберігання ip-адрес. Нижче перелічені найбільш важливі та часто використовувані. Із всіма типами даних, можна ознайомитись в документації.
https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html

---

Базові типи даних

- `boolean` - true/false
- `text` - тип для full-text пошуку
- `date` - для збереження дати

---

В elastic є багато різновидів числових типів даних, в основному вони поділяються на `integer` та `float`, і вони в свою чергу відрізняються мін та макс числом яке може бути збережене в них. https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html:

---

`keyword`
- Використовується для точного співпадіння по пошуку. Наприклад, можемо використовувати для: `email`, `country`, `status` - у цих всіх випадках нам потрібне точне співпадіння.
- Тут не працює full-text пошук, тому що нам потрібно точне співпадіння. Якщо потрібно саме full-text пошук, то потрібно обрати `text` тип даних.
- Під цим типом даних, мається на увазі що дані зберігається, в тому форматі як вони були відправлені (тобто, не застосовується `analyzer`). Якщо ми збережемо ось такий рядок `Just some Text! :)`, то цей рядок так і буде збережений (він не буде розбитий на `terms`). І в подальшому щоб знайти цей рядок, потрібно буде написати точно такий ж самий текст, тому що тут очікується що буде 100% співпадіння


---

`object`
- цей тип даних відображає JSON-об'єкт. Тобто, в полі документа можемо зберігати JSON-об'єкт, і цей JSON-об'єкт може містити в собі вкладений інший JSON-об'єкт. Якщо подивитись на прикладі нижче, то в індексі `products` є поле `manufacturer` яке є JSON-об'єктом.
  ```
    PUT /products
    {
        "mappings": {
            "properties": {
                "name": {"type": "text"},
                "price": {"type": "double"},
                "in_stock": {"type": "short"},
                "is_active": {"type": "boolean"},
                "manufacturer": {
                    "properties": {
                        "name": {"type": "text"},
                        "country": {"type": "text"},
                    }
                },
            }
        }
    }
    ```
- elastic не зберігає JSON-об'єкт саме в такому вигляді. Тому що elastic створений над Apache Lucene, який не підтримує збереження об'єктів. Тому ці об'єкти зберігаються розділені крапкою (flattened), приклад нижче. В подальшому, при пошуку та фільтрації документів ми можемо використовувати цей flattened стиль.
  ```
  {
      "manufacturer.name": "Iphone",
      "manufacturer.country": "USA",
  }
  ```

---

`nested`
- це також JSON-об'єкт, тільки призначений для зберігання масиву об'єктів.
- щоб зрозуміти різницю між `object` та `nested`, потрібно зрозуміти можливу проблему. Уявимо що ми маємо таку структуру, де поле `user` є типом `object`, і в цьому полі ми зберігаємо масив об'єктів.
```
{
  "user" : [ 
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}
```
- в подальшому, коли ми захочемо знайти дані `WHERE first = 'John' AND last = 'White'`, то elastic не зрозуміє що дані потрібно шукати в одному об'єкті, тобто elastic знайде `first = 'John'` в першому об'єкті масива, і знайде `last = 'White'` в другому об'єкті масива, і в результаті поверне цей документ, тому що він знайшов співпадіння.
- якщо ми обираємо тип даних `nested`, то elastic в цьому запиті `WHERE first = 'John' AND last = 'White'` буде дивитись, щоб ці дані знаходилось в одному об'єкті. І в цьому випадку співпадінь не буде, тому що немає об'єкта в якого було б `first = 'John'` та `last = 'White'`.

---

#### Array

В elastic немає типу даних `array`, але якщо ми спробуємо зберегти масив даних, то це буде працювати. В цьому випадку дані зберігаються із типом `text`. Тобто, elastic всередині зберігає ці дані як `text`, а не як масив.

---

#### Coercion
Це механізм який дозволяє динамічно визначати тип даних. Наприклад в нас є поле `amount` із типом даних `float`. Якщо ми спробуємо вставити дані `"1.22"`, то це спрацює, тому що elastic спробує привести стрінг значення `"1.22"` до float типу даних. Якщо ж ми спробуємо вставити `"hello world"`, то elastic поверне помилку, тому що не можливо конвертувати це значення в тип `float`. <br>
Цю поведінку можна глобально включити/виключити. По замовчуванні вона включена, тобто, elastic спробує привести тип даних до потрібного, і тільки якщо це не получиться, то тільки тоді буде error. Якщо ж ми хочемо щоб elastic одразу повертав error, якщо типи даних не співпадають, то це можна глобально виключити. <br>

Нижче показано що ми відключаємо цю поведінку для поля `amount`
```
PUT /sales
{
    "mappings": {
        "properties": {
            "amount": {
                "type": "float",
                "coerce": false
            }
        }
    }
}
```

Нижче показано що ми виключаємо цю поведінко глобально для індекса, але включаємо для поля `amount`
```
PUT /sales
{
    "settings": {
        "index.mapping.coerce": false
    },
    "mappings": {
        "properties": {
            "amount": {
                "type": "float",
                "coerce": true
            }
        }
    }
}
```